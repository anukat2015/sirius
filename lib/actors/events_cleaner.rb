require 'celluloid'
require 'actors/etl_consumer'
require 'event'

class EventsCleaner
  include Celluloid
  include ETLConsumer

  def initialize(input, parent_actor, faculty_semester, event_type)
    self.input = input
    @parent_actor = parent_actor
    @seen_event_ids = Set.new
    @faculty_semester = faculty_semester
    @event_type = event_type
  end

  # Stores an array of events for later processing by {#mark_unseen_events!}.
  #
  # @param saved_events [Array<Event>] events that were generated by previous import steps
  #   and were synced to the database, meaning that they have their primary key set.
  def process_row(saved_events)
    @seen_event_ids = @seen_event_ids + saved_events.map(&:id)
    notify_hungry
  end

  # Performs final action on stored events and then notifies parent actor with
  # EOF message.
  def process_eof
    mark_unseen_events!(@faculty_semester, @seen_event_ids, @event_type)
    Celluloid::Actor[@parent_actor].async.receive_eof
  end

  # Marks events in the database from currently processed faculty semester and having given type
  # that were not generated by the current import run.
  #
  # These events are marked as `deleted`, because their source object either disappeared from KOS(api) or
  # semester parameters changed so that they are no longer generated.
  def mark_unseen_events!(faculty_semester, seen_event_ids, event_type)
    Event.where(
      faculty: faculty_semester.faculty,
      semester: faculty_semester.code,
      deleted: false,
      event_type: event_type
    ).exclude(id: seen_event_ids.to_a)
    .update(deleted: true, updated_at: Sequel.function(:NOW))
  end
end
